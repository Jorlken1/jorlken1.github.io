<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jorlken1.github.io</id>
    <title>jorlken Notes</title>
    <updated>2022-06-10T02:54:53.238Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jorlken1.github.io"/>
    <link rel="self" href="https://jorlken1.github.io/atom.xml"/>
    <subtitle>勤学如春起之苗，不见其长，日有精进</subtitle>
    <logo>https://jorlken1.github.io/images/avatar.png</logo>
    <icon>https://jorlken1.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, jorlken Notes</rights>
    <entry>
        <title type="html"><![CDATA[2.4 框架应该输出怎么样的产物]]></title>
        <id>https://jorlken1.github.io/post/24-kuang-jia-ying-gai-shu-chu-zen-me-yang-de-chan-wu/</id>
        <link href="https://jorlken1.github.io/post/24-kuang-jia-ying-gai-shu-chu-zen-me-yang-de-chan-wu/">
        </link>
        <updated>2022-06-02T08:56:39.000Z</updated>
        <content type="html"><![CDATA[<p>根据环境输出产物</p>
<ol>
<li>
<p>HTML中直接用script标签引入使用<br>
运用立即执行函数(IIFE)包裹，全局的Vue就可以使用了。<br>
使用：在rollup.js中，通过配置format:iife,即可输出该形式资源。</p>
</li>
<li>
<p>esm格式资源<br>
用户用<code>&lt;script type=&quot;module&quot; src=&quot;/path/to/vue.esm-browser.js&quot;&gt;&lt;/script&gt;</code>引入<br>
使用：配置format:esm。<br>
由于配置环境变量的不同，vue.runtime.esm-bundler.js 为提供给webpack和roll等打包工具使用。</p>
</li>
<li>
<p>cjs格式资源<br>
node使用<code>const vue = require(&quot;vue&quot;)</code> 引入，用于服务端渲染（ssr）。</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2.3 框架要做到良好的tree-shaking]]></title>
        <id>https://jorlken1.github.io/post/23-kuang-jia-yao-zuo-dao-liang-hao-de-tree-shaking/</id>
        <link href="https://jorlken1.github.io/post/23-kuang-jia-yao-zuo-dao-liang-hao-de-tree-shaking/">
        </link>
        <updated>2022-05-26T06:06:20.000Z</updated>
        <content type="html"><![CDATA[<h1 id="tree-shaking">Tree-Shaking</h1>
<p>指的是消除永远不会执行的代码<br>
注意：</p>
<ol>
<li>模块语法必须是ES Module</li>
<li>只会清除不对外部造成影响（副作用）的模块</li>
</ol>
<p>如果确定函数不会造成影响，则可以注释代码告诉打包工具，可以放心对其清除。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2.2 控制框架代码体积]]></title>
        <id>https://jorlken1.github.io/post/22-kong-zhi-kuang-jia-dai-ma-ti-ji/</id>
        <link href="https://jorlken1.github.io/post/22-kong-zhi-kuang-jia-dai-ma-ti-ji/">
        </link>
        <updated>2022-05-25T03:24:07.000Z</updated>
        <content type="html"><![CDATA[<p>通过控制环境变量 <em>DEV</em> 可以在开发环境给开发者提供良好的开发体验的同时，不会增加生产环境的体积。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2.1 提升用户的开发体验]]></title>
        <id>https://jorlken1.github.io/post/21-ti-sheng-yong-hu-de-kai-fa-ti-yan/</id>
        <link href="https://jorlken1.github.io/post/21-ti-sheng-yong-hu-de-kai-fa-ti-yan/">
        </link>
        <updated>2022-05-25T03:20:18.000Z</updated>
        <content type="html"><![CDATA[<p>例：</p>
<ol>
<li>提供必要的警告信息</li>
<li>编写自定义formatter去优化控制台输出</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于领导方法的若干问题]]></title>
        <id>https://jorlken1.github.io/post/guan-yu-ling-dao-fang-fa-de-ruo-gan-wen-ti/</id>
        <link href="https://jorlken1.github.io/post/guan-yu-ling-dao-fang-fa-de-ruo-gan-wen-ti/">
        </link>
        <updated>2022-05-25T02:55:03.000Z</updated>
        <content type="html"><![CDATA[<h1 id="两个方法">两个方法</h1>
<ol>
<li>一般与个别相结合。</li>
<li>领导与群众相结合。</li>
</ol>
<h1 id="普遍和一般的号召">普遍和一般的号召</h1>
<p>从下级和别人员或事件获取具体经验，再向一切单位作指导。</p>
<h1 id="领导骨干和广大群众相结合">领导骨干和广大群众相结合</h1>
<p>需要培养团结一致，联系群众的经常健全的骨干。</p>
<h1 id="从群众中来再到群众中去">从群众中来再到群众中去</h1>
<p>收集群众的意见，经研究化为系统性的意见，再到群众中去宣传解释，考验意见是否正确，循环往复。</p>
<h1 id="工作任务需要分工且统一">工作任务需要分工且统一</h1>
<p>让领导和下级领导都负起责任。</p>
<h1 id="抓住问题的主要矛盾的主要方面具体问题具体分析">抓住问题的主要矛盾的主要方面，具体问题具体分析</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1.4 运行时和编译时]]></title>
        <id>https://jorlken1.github.io/post/14-yun-xing-shi-he-bian-yi-shi/</id>
        <link href="https://jorlken1.github.io/post/14-yun-xing-shi-he-bian-yi-shi/">
        </link>
        <updated>2022-05-24T00:53:51.000Z</updated>
        <content type="html"><![CDATA[<h1 id="运行时框架">运行时框架</h1>
<p>用户提供描述dom的数据对象，使用框架后转化为命令。</p>
<h1 id="编译时框架">编译时框架</h1>
<p>用户提供模版字符串，经编译转化为命令。</p>
<h1 id="运行时-编译时-框架-vue">运行时 + 编译时 框架 （vue）</h1>
<p>用户提供模版字符串，经编译为描述dom的数据对象，再转化为命令。</p>
<p>设计目的：使用编译时保持可读性的同时，通过运行时尽可能去优化。（不输纯编译时）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1.3 虚拟DOM]]></title>
        <id>https://jorlken1.github.io/post/13-xu-ni-dom/</id>
        <link href="https://jorlken1.github.io/post/13-xu-ni-dom/">
        </link>
        <updated>2022-05-24T00:28:03.000Z</updated>
        <content type="html"><![CDATA[<h1 id="innerhtml">innerHTML</h1>
<pre><code>const html = `
    &lt;div&gt;&lt;span&gt;...&lt;/span&gt;&lt;div&gt;
`
div.innerHTML = html
</code></pre>
<p>性能：<br>
html字符串拼接性能 + innnerHTML 的 dom 计算量（损耗非常大）</p>
<h1 id="虚拟dom">虚拟DOM</h1>
<ol>
<li>创建js对象，描述真实dom。</li>
<li>递归遍历对象，渲染真实dom。</li>
</ol>
<p>性能：<br>
创建js对象计算量 + 创建真实dom计算量</p>
<h1 id="原生js">原生js</h1>
<p>创建真实dom</p>
<p>性能：创建真实dom 计算量</p>
<p>可读性：innerHTML = 虚拟DOM &gt; 原生js<br>
性能：原生js &gt;= 虚拟DOM &gt;&gt; 原生js</p>
<p>结论：<br>
<strong>虚拟DOM 在保证一定性能的情况下，拥有很好的可读性</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1.2 性能与可维护性的平衡]]></title>
        <id>https://jorlken1.github.io/post/12-xing-neng-yu-ke-wei-hu-xing-de-ping-heng/</id>
        <link href="https://jorlken1.github.io/post/12-xing-neng-yu-ke-wei-hu-xing-de-ping-heng/">
        </link>
        <updated>2022-05-24T00:09:30.000Z</updated>
        <content type="html"><![CDATA[<pre><code>命令式代码的性能损耗 = 直接修改的性能损耗
声明式代码的性能损耗 = 直接修改的性能损耗 + 找出差异修改的性能损耗
</code></pre>
<p>声明式代码的<strong>性能损耗</strong> 大于等于 命令式代码的<strong>性能损耗损耗</strong><br>
但 声明式代码 的<strong>可读性</strong> 大于等于 命令式代码 的<strong>可读性</strong></p>
<p>设计目的 ： 保持可读性的同时，让性能损失最小化。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1.1 视图层框架的分类]]></title>
        <id>https://jorlken1.github.io/post/11-shi-tu-ceng-kuang-jia-de-fen-lei/</id>
        <link href="https://jorlken1.github.io/post/11-shi-tu-ceng-kuang-jia-de-fen-lei/">
        </link>
        <updated>2022-05-19T07:00:51.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>命令式<br>
用户通过发布一条条命令，完成特定的功能。命令式的一大特点为<code>关注功能</code>。</li>
<li>声明式<br>
用户通过直接阐述所需要生成的标签结果，即可完成特定功能。</li>
</ol>
<p>举例：<br>
<code>我要生成一个有点击事件和文本&quot;hello world&quot;的div标签</code></p>
<p>命令式框架需要进行以下编码：</p>
<pre><code>const div = document.querySelect('#app') // 获取页面中id为app的div
div.innerText =  'hello world' // 设置文本内容
div.addEventlistener('click',()=&gt;{alert('ok')})// 绑定点击事件   
</code></pre>
<p>而声明式框架则仅仅需要进行以下编码：</p>
<pre><code>&lt;div @click=&quot;()=&gt;{alert('ok')}&quot;&gt;hello world&lt;/div&gt;
</code></pre>
<p>Vue的内部实现是<strong>命令式</strong>的，而用户层则是<strong>声明式</strong>的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[基于Vue的视频播放器（支持视频流、直播流）]]></title>
        <id>https://jorlken1.github.io/post/Vue-Easy-Player/</id>
        <link href="https://jorlken1.github.io/post/Vue-Easy-Player/">
        </link>
        <updated>2022-05-13T00:49:29.000Z</updated>
        <content type="html"><![CDATA[<p>由于之前用过vedio-player接入直播流遇到了不好用，支持的格式少，性能不稳定等问题，后发现easy-player可以完美兼容及用户体验良好，故将项目的直播流接入Easy-player，推荐大家使用它。</p>
<p>接下来分享关于easy-player的操作以及使用的方法。</p>
<h2 id="第一步打开终端用npm下载easy-player">第一步：打开终端，用npm下载Easy-player</h2>
<p><code>npm install easy-player</code></p>
<p>如遇到下载失败的问题可以去网上搜寻错误关键字，或使用 <strong>npm淘宝镜像</strong>，<strong>cnpm</strong>，<strong>yarn</strong>改善下载问题。</p>
<h2 id="第二步移动文件">第二步：移动文件</h2>
<p>在项目的依赖包 <code>node_modules</code> 里，找到 <code>easy-player</code> 文件夹</p>
<figure data-type="image" tabindex="1"><img src="https://jorlken1.github.io/post-images/1652408721487.png" alt="" loading="lazy"></figure>
<p>在 <code>easy-player</code>文件夹 下的 <code>dist</code> 文件夹 下的 <code>component</code>文件夹 中复制这三个文件</p>
<figure data-type="image" tabindex="2"><img src="https://jorlken1.github.io/post-images/1652408729314.png" alt="" loading="lazy"></figure>
<p>粘贴到与 <code>node_modules</code>文件夹 同级的 <code>public</code> 文件夹 中即可使用</p>
<h2 id="第三步引入文件">第三步：引入文件</h2>
<p>进入 <code>public</code> 文件夹 中的 <code>index.html</code> 文件 中，用 <em>script</em> 标签引入 <em>easy-player</em></p>
<pre><code>&lt;html lang=&quot;zh-cmn-Hans&quot;&gt;
  &lt;head&gt;
    ...
    &lt;script src=&quot;./easy-player-lib.min.js&quot;&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
      ...
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="第四步去vue文件中使用">第四步：去.vue文件中使用</h2>
<pre><code>&lt;template&gt;
    ...
      &lt;EasyPlayer
        :videoUrl=&quot;src&quot; // 你的视频文件
        aspect=&quot;19:9&quot;  // 你的视频长宽的比例
        live // 是否接受直播流
        autoplay // 是否自动播放
        stretch // 视频比例是否自适应
        style=&quot;width:100%;height:60px&quot; // 调节样式
        //更多配置项在后文补充
      &gt;&lt;/EasyPlayer&gt;
    ...
&lt;/template&gt;
&lt;script&gt;
...
import EasyPlayer from 'easy-player'
...
export default {
  ...
  components: {
    EasyPlayer
  }
  ...
}
&lt;/script&gt;
</code></pre>
<p>至此，easy-player就可以使用啦</p>
<p>ps:为了保证public文件夹的干净整洁，可以将需要的三个文件放在一个独立的文件夹下方便管理。</p>
<h2 id="补充可配置项">补充可配置项</h2>
<p><strong>属性(Property)</strong></p>
<ul>
<li><code>video-url</code> 视频流地址 String default ''</li>
<li><code>video-title</code> 视频右上角显示的标题 String default ''</li>
<li><code>poster</code> 视频封面图片 String default ''</li>
<li><code>autoplay</code> 自动播放 Boolean default true</li>
<li><code>loop</code> 是否循环播放 Boolean default false</li>
<li><code>live</code> 是否直播, 标识要不要显示进度条 Boolean default false</li>
<li><code>alt</code> 视频流地址没有指定情况下, 视频所在区域显示的文字, 相当于 html img 标签的 alt 属性 String default '无信号'</li>
<li><code>muted</code> 是否静音 Boolean default false</li>
<li><code>aspect</code> 视频显示区域的宽高比 String default '16:9'</li>
<li><code>loading</code> 指示加载状态, 支持 sync 修饰符</li>
<li><code>fluent</code> 流畅模式, Boolean default true</li>
<li><code>stretch</code> 是否拉伸, Boolean default false</li>
<li><code>timeout</code> m3u8 加载超时(秒) Number default 20</li>
<li><code>show-custom-button</code> 是否在工具栏显示自定义按钮(极速/流畅, 拉伸/标准), Boolean default true</li>
</ul>
<p><strong>方法(Medthod)</strong></p>
<ul>
<li><code>getCurrentTime</code> 获取当前播放时间进度, 同步返回播放时间进度数据</li>
<li><code>snap</code> 外部 API 方式获取快照, 快照获取成功后, 触发 snapOutside Event</li>
</ul>
<p><strong>事件(Event)</strong></p>
<ul>
<li><code>message</code> 触发通知消息, 参数: { type: '', message: ''}</li>
<li><code>ended</code> 播放结束, 参数: 无</li>
<li><code>timeupdate</code> 进度更新, 参数: 当前时间进度</li>
<li><code>pause</code> 暂停, 参数: 当前时间进度</li>
<li><code>play</code> 播放, 参数: 当前时间进度,</li>
<li><code>snapOutside</code> 外部快照回调, 参数: 快照 Base64 数据</li>
<li><code>snapInside</code> 内部快照回调, 由控制栏快照按钮触发, 参数: 快照 Base64 数据</li>
</ul>
]]></content>
    </entry>
</feed>